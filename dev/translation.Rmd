---
title: "Translation"
author: "Colin Fay"
date: "`r Sys.Date()`"
output: html_document
---

```{r}
pkgload::load_all(attach_testthat = FALSE)
session <- new.env()
connect(session)
library(dplyr)
```

## Comment est organis√©e la traduction

__Note importante__ : Pensez √† √™tre bien vigilant sur l'harmonisation des code-langues. 
En d'autres termes, si l'on ajoute une langue avec le code `es`, ce code doit √™tre strictement resp√©ct√© partout, sinon la traduction ne pourra pas √™tre effectu√©e correctement dans l'applicatino. 

### Pour les "help bubble"

Les help bubbles sont les √©l√©ments d'aide lors du passage de la souris sur un √©l√©ment `(?)`.

Ils sont tous dans `inst/translation_help`. 
Ce dossier contient des sous-dossiers, chacun correspondant √† une bulle d'aide. 
Chacun de ces  sous dossiers contient des `.md`, un par code-langue. 
Vous pouvez utiliser du code Markdown afin de remplir ces √©l√©ments. 

Ces contenus sont ensuite compil√©s dans `inst/translation_help.csv`, via le code ci-dessous, √† relancer en cas de changement.  

```{r}
unlink("inst/translation_help.csv")

purrr::map_df(
  list.files(
    "inst/translation_help",
    full.names = TRUE
  ), ~ {
    data.frame(
      entry = basename(.x),
      en = htmltools::includeMarkdown(
        file.path(.x, "en.md")
      ),
      fr = htmltools::includeMarkdown(
        file.path(.x, "fr.md")
      )
    )
  }
) %>%
  readr::write_csv("inst/translation_help.csv")
```

### Pour le front-end 

Pour l'interface utilisateur, l'application met ensemble des fichiers CSV, contenus dans le dossier `inst/` et des tables contenues dans la base. 
Certains de ces fichiers sont automatiquement g√©n√©r√©s, un est √† modifier √† la main. 

Tous ces fichiers contiennent au moins 3 colonnes: 

+ `entry` : la cl√© d'entr√©e dans le front (pour i18n)
+ `en` : la traduction en anglais
+ `fr` : la traduction en fran√ßais

### Lus dans la base

+ `abundance_level`
```{r}
translation_abundance_level <- function(session = shiny::getDefaultReactiveDomain()) {
  # TODO √©crire depuis la base
  DBI::dbGetQuery(
    get_con(session),
    "select abundance_level_name AS entry, abundance_level_interpretation_short AS en from abundance_level"
    # "select abundance_level_name AS entry, abundance_level_interpretation_short AS en, diadesatlas.translate(abundance_level_interpretation_short, 'fr') AS fr from abundance_level"
  ) %>%
    # Cette traduction est temporaire, il FAUDRA utiliser la traduction depuis la base de donn√©es,
    # via le code SQL comment√©
    mutate(
      fr = c(
        "Non enregistr√© sur la p√©riode",
        "Pr√©sence occasionnelle",
        "Populations fonctionnelles",
        "Populations fonctionnelles abondante"
      )
    )
}
translation_abundance_level(se)
```

+ `species` : contient les traductions pour les √©l√©ments de niveau d'abondance. 
Se g√©n√®re via le code suivant : 

```{r}
translation_species <- function(session = shiny::getDefaultReactiveDomain()) {
  DBI::dbGetQuery(
    get_con(session),
    "SELECT local_name AS entry, english_name AS en, diadesatlas.translate(english_name, 'fr') AS fr from diadesatlas.species WHERE active=TRUE"
  )
}
translation_species(se)
```

+ `v_ecosystemic_services`

```{r}
translation_v_ecosystemic_services <- function(session = shiny::getDefaultReactiveDomain()) {
  dplyr::bind_rows(
    DBI::dbGetQuery(
      get_con(session),
      "SELECT
        REPLACE(LOWER(casestudy_name), ' ', '-') as entry,
        casestudy_name as en,
        diadesatlas.translate(casestudy_name, 'fr') as fr
        from v_ecosystemic_services"
    ),
    DBI::dbGetQuery(
      get_con(session),
      "SELECT
        REPLACE(LOWER(category_name), ' ', '-') as entry,
        category_name as en,
        diadesatlas.translate(category_name, 'fr') as fr
        from v_ecosystemic_services"
    ),
    DBI::dbGetQuery(
      get_con(session),
      "SELECT
        REPLACE(LOWER(subcategory_name), ' ', '-') as entry,
        subcategory_name as en,
        diadesatlas.translate(subcategory_name, 'fr') as fr
        from v_ecosystemic_services"
    ),
    DBI::dbGetQuery(
      get_con(session),
      "SELECT
        REPLACE(LOWER(subcategory_name), ' ', '-') as entry,
        subcategory_name as en,
        diadesatlas.translate(subcategory_name, 'fr') as fr
        from v_ecosystemic_services"
    )
  )
}
translation_v_ecosystemic_services(se)
```

### Fichiers g√©n√©r√©s automatiquement 

+ `translation_iucn.csv` : contient les traductions pour status IUCN. 
Se g√©n√®re via le code suivant __mais devra √™tre mis dans la base__.

```{r}
# TODO : get the translation inside the DB
# On utilise ici la description trouv√©e sur
# https://uicn.fr/liste-rouge-mondiale/
desc <- strsplit(
  "√âteinte (EX), √âteinte √† l‚Äô√©tat sauvage (EW), En danger critique (CR), En danger (EN), Vuln√©rable (VU), Quasi menac√©e (NT), Pr√©occupation mineure (LC), Donn√©es insuffisantes (DD), Non √©valu√©e (NE)",
  split = ", "
)[[1]]

french_iucn <- data.frame(
  fr_vals = gsub(
    "([^\\(]+) \\(([^\\(]+)\\)",
    "\\1,\\2",
    desc
  )
) %>%
  tidyr::separate(
    fr_vals,
    into = c("fr", "entry"), sep = ","
  )

en_iucn <- DBI::dbGetQuery(
  get_con(se),
  "SELECT distinct iucn_level_code AS entry,iucn_level_name AS en FROM v_iucn"
)

en_iucn %>%
  dplyr::full_join(french_iucn) %>%
  readr::write_csv("inst/translation_iucn.csv")
```

### Fichier √† compl√©ter √† la main 

__IMPORTANT__ Merci de centraliser dans le Google Sheet. 

+ On va lire le fichier Google Sheet de traduction. 

```{r}
library(googlesheets4)
sheet_url <- readline("Enter the sheet url: ")
translation <- read_sheet(sheet_url)

translation$DESCRIPTION <- NULL

translation
```

V√©rifier (et manipulez) le dataframe au besoin. 
Ce dernier doit poss√©der √† minima : 

+ Une premi√®re colonne nomm√©e 'entry'
+ Une seconde colonne nomm√©e 'en'
+ Une troisis√®me colonne nomm√©e 'fr'
+ D'autres langues (potentiellement)
+ PAS DE COLONNES VIDES SUR LA DROITE, pensez √† l'anti-s√©lectionner au besoin

```{r}
readr::write_csv(
  translation,
  "inst/translation.csv"
)
```

Vous pouvez v√©rifier l'int√©grit√© du csv :

```{r}
output <- check_translation_csv("inst/translation.csv")
head(output)
```

## Ajouter une nouvelle langue 

Ajouter une nouvelle langue doit se faire aux emplacements suivants:

### Help bubbles

+ Pour chaque sous-dossiers, ajouter un fichier `.md` avec la traduction dans une nouvelle langue. 

+ R√©g√©nerer `translation_help.csv` : dans le code de g√©n√©ration de la premi√®re partie de ce Rmd, remplacer avec un code type

```{r}
data.frame(
  entry = basename(.x),
  en = htmltools::includeMarkdown(
    file.path(.x, "en.md")
  ),
  fr = htmltools::includeMarkdown(
    file.path(.x, "fr.md")
  ),
  # Code pour la nouvelle langue
  es = htmltools::includeMarkdown(
    file.path(.x, "es.md")
  )
)
```

### Data 

+ Fichier Google Sheet, ajouter une nouvelle colonne √† droite (exemple `es`)

+ `translation_iucn.csv` : dans le code de g√©n√©ration du dessus, il faudra cr√©er un nouveau data.frame, avec les traductions. 

> Note : ces traductions devront √† termes √™tre int√©gr√©es √† la base

```{r}
es_iucn <- data.frame(
  entry = c("EX", "EW", "CR", "EN", "VU", "NT", "LC", "DD", "NE"),
  es = c("", "", "", "", "", "", "", "", "")
)
```

puis mettre √† jour le code du d√©but de ce Rmd.

```{r}
en_iucn %>%
  dplyr::full_join(french_iucn) %>%
  dplyr::full_join(es_iucn) %>%
  readr::write_csv("inst/translation_iucn.csv")
```

### Fonction dbb

Ces fonctions sont dans `R/utils_helpers.R`

Les fonctions qui utilisent la traduction dans la bdd sont les suivantes : 

+ `translation_abundance_level()` : il faudra ajouter une partie au SQL type `diadesatlas.translate(abundance_level_interpretation_short, 'es') AS es`

+ `translation_species()` : il faudra ajouter une partie au SQL type `diadesatlas.translate(english_name, 'es') AS es`

+ `translation_v_ecosystemic_services()` pour chaque sous requ√™te SQL, il faudra ajouter une partie au SQL type `diadesatlas.translate(subcategory_name, 'es') as es` 

### C√¥t√© code de l'application

- Si disponible, ajouter le langage dans `get_dt_lg()` , √† v√©rifier sur https://cdn.datatables.net/plug-ins/1.10.11/i18n/

- Dans `R/app_ui.R`, ajouter une entr√©e pour le s√©lecteur de langue. Si votre entr√©e de laangue est `es`, ajouter `<option value="en">\U0001f1ea\U0001f1f8 Espanol</option>`. Le code unicode s'obtient en utilisant l'√©moji et `stringi::stri_escape_unicode("üá™üá∏")`.

## Notes pour les d√©velopeurs 

### Comment cr√©er un nouvel √©l√©ment "traductible" dans l'UI

+ La traduction est assur√©e par le module JS `i18n` et la fonction `with_i18()` dans l'app

```{r}
with_i18(
  "Text de base",
  "text_de_base"
)
```

Va cr√©er `<span data-i18n="text_de_base">Text de base</span>`. 

+ L'√©l√©ment `Text de base` est affich√© si `i18n` plante
+ L'√©l√©ment `data-i18n="text_de_base"` correspond √† la cl√© d'entr√©e dans le data.frame de traduction, i.e. la valeur dans la colonne entry. 

Sch√©matiquement, lorsque le JavaScript va traduire la page, il va aller chercher pour chaque tag l'entr√©e `data-i18n`, en tirer la valeur, et aller chercher la traduction correspondante. 

Par exemple, si nous traduisons en "fr", la localisation fait (en JavaScript) l'action suivante 

```{r eval = FALSE}
df_traduction %>%
  filter(entry == "text_de_base") %>%
  pull(fr)
```

